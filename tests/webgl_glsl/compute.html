<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>WebGL Compute Example</title>
	</head>
	<body>
		<button id="go">Go!</button>
	</body>
<script id="vshader" type="text/plain">
	attribute vec2 vtxpos;
	varying vec2 texpos;
	void main() {
		texpos = (vtxpos / 2.) + vec2(0.5, 0.5);
		gl_Position = vec4(vtxpos, 0, 1);
	}
</script>
<script id="fshader" type="text/plain">
	precision mediump float;
	varying vec2 texpos;
	uniform sampler2D tex0;

	float in_data_length() { return IN_DATA_LENGTH; }
	float in_data_width() { return IN_DATA_SIZE; }
	float in_data_height() { return IN_DATA_SIZE; }
	float out_data_width() { return OUT_DATA_WIDTH; }
	float out_data_height() { return OUT_DATA_HEIGHT; }

	int get_output_index() {
		float x = floor(texpos.x * out_data_width());
		float y = floor(texpos.y * out_data_width());
		float i = (y * in_data_height()) + x;
		return int(i);
	}

	int shift_right(int data, int times) {
	    if (times > 0) {
	        return data / int(pow(2.0, float(times)));
	    } else {
	        return data;
	    }
	}

	int shift_left(int data, const int times) {
	    if (times > 0) {
	        return data * int(pow(2.0, float(times)));
	    } else {
	        return data;
	    }
	}

	vec4 int_to_vec4(const int data) {
	    int mask = shift_left(shift_right(data, 8), 8);
	    float r = float(data - mask) / 255.0;

	    mask = shift_left(shift_right(data, 16), 16);
	    float g = float(shift_right(data - mask, 8)) / 255.0;

	    mask = shift_left(shift_right(data, 24), 24);
	    float b = float(shift_right(data - mask, 16)) / 255.0;

	    float a = float(shift_right(data, 24)) / 255.0;
	    return vec4(r, g, b, a);
	}

	const int N = 43;

	int fibonacci() {
		if (N <= 1) {
			return N;
		}
		int result = 1;
		int prev = 1;
		for (int i=2; i<N; ++i) {
			int temp = result;
			result += prev;
			prev = temp;
		}
		return result;
	}

	void main() {
		if (get_output_index() == 0) {
			int result = fibonacci();
			gl_FragColor = int_to_vec4(result);
			//gl_FragColor = vec4(float(0x19) / 255.0, float(0xD6) / 255.0, float(0x99) / 255.0, float(0xA5) / 255.0);
		} else {
			//gl_FragColor = vec4(0, 0, 0, 0);
		}
	}
</script>
<script type="text/javascript">

	function main() {
		var array_buffer = new ArrayBuffer(8);
		var OUT_DATA_WIDTH = 128;
		var OUT_DATA_HEIGHT = 128;
		var IN_DATA_SIZE = Math.pow(2, 7);//128 * 128 texture;
		var IN_DATA_LENGTH = array_buffer.byteLength;

		// Get A WebGL context
		var surface = document.createElement('canvas');
		surface.width = OUT_DATA_WIDTH;
		surface.height = OUT_DATA_HEIGHT;
		surface.setAttribute('style', "border: 1px solid black");
		document.body.appendChild(surface);
		var gl = surface.getContext('webgl') || surface.getContext('experimental-webgl');
		if (! gl) {
			console.error('Failed to init WebGL');
			return;
		}

		// Print the open gl version
		console.info('WebGL Version: ' + gl.getParameter(gl.VERSION));
		console.info('GLSL Version: ' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
		console.info('Vendor: ' + gl.getParameter(gl.VENDOR));
		/*
		var ext = gl.getExtension('WEBGL_debug_renderer_info');
		if (ext) {
			console.info(gl.getParameter(ext.UNMASKED_VENDOR_WEBGL));
			console.info(gl.getParameter(ext.UNMASKED_RENDERER_WEBGL));
		}
		*/

		// Compile the Vertex Shader
		var shaderSource = document.getElementById('vshader').textContent;
		var shaderVertex = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(shaderVertex, shaderSource);
		gl.compileShader(shaderVertex);
		var compiled = gl.getShaderParameter(shaderVertex, gl.COMPILE_STATUS);
		if (! compiled) {
			var lastError = gl.getShaderInfoLog(shaderVertex);
			console.error("Shader compile error:" + lastError);
			gl.deleteShader(shaderVertex);
		}

		// Inject our sizes into the shader source code
		var shaderSource = document.getElementById('fshader').textContent;
		shaderSource = shaderSource.replace(/OUT_DATA_WIDTH/g, OUT_DATA_WIDTH + '.0');
		shaderSource = shaderSource.replace(/OUT_DATA_HEIGHT/g, OUT_DATA_HEIGHT + '.0');
		shaderSource = shaderSource.replace(/IN_DATA_SIZE/g, IN_DATA_SIZE + '.0');
		shaderSource = shaderSource.replace(/IN_DATA_LENGTH/g, IN_DATA_LENGTH + '.0');

		// Compile the Fragment Shader
		var shaderFragment = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(shaderFragment, shaderSource);
		gl.compileShader(shaderFragment);
		var compiled = gl.getShaderParameter(shaderFragment, gl.COMPILE_STATUS);
		if (! compiled) {
			var lastError = gl.getShaderInfoLog(shaderFragment);
			console.error("Shader compile error:" + lastError);
			gl.deleteShader(shaderFragment);
		}

		// Build the program
		var program = gl.createProgram();
		gl.attachShader(program, shaderVertex);
		gl.attachShader(program, shaderFragment);
		gl.linkProgram(program);
		var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
		if (! linked) {
			var lastError = gl.getProgramInfoLog(program);
			console.error("Program link error:" + lastError);
		}
		gl.useProgram(program);

		// Create a vertex buffer
		var vertexPosBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
		var vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		vertexPosBuffer.itemSize = 2;
		vertexPosBuffer.numItems = 4;

		// Setup the attributes, uniforms, and textures
		gl.enableVertexAttribArray(program.vertexPosArray);
		gl.vertexAttribPointer(program.vtxpos, 2, gl.FLOAT, false, 0, 0);
		program.vtxpos = gl.getAttribLocation(program, 'vtxpos');
		program.sampler = [gl.getUniformLocation(program, 'tex0')];
		program.tex = [gl.createTexture()];

		// Create the input buffer
		var inBuffer = new Uint8Array(4 * IN_DATA_SIZE * IN_DATA_SIZE);
		console.info('In buffer size:  ' + inBuffer.byteLength);
		console.info('Data size:       ' + array_buffer.byteLength);
		var view = new Uint8Array(array_buffer);
		for (var i = 0; i < view.length; ++i) {
			inBuffer[i] = view[i];
		}

		// Create the output buffer
		var outBuffer = new Uint8Array(4 * OUT_DATA_WIDTH * OUT_DATA_HEIGHT);
		console.info('Out buffer size: ' + outBuffer.byteLength);

		function getLine(source, index, size) {
			var line = new Array(size);
			for (var i=0; i<size; ++i) {
				line[i] = String.fromCharCode(source[index + i]);
			}
			return line.join('');
		}

		function blit() {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, program.tex[0]);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, IN_DATA_SIZE, IN_DATA_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, inBuffer);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.uniform1i(program.sampler[0], 0);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.readPixels(0, 0, OUT_DATA_WIDTH, OUT_DATA_HEIGHT, gl.RGBA, gl.UNSIGNED_BYTE, outBuffer);
		};
		blit();
/*
		for (var i=0; i<outBuffer.length; ++i) {
			if (outBuffer[i] != 0) {
				console.info(i + ', ' + outBuffer[i]);
			}
		}
*/
		for (var i=0; i<4; ++i) {
			console.info(i + ', ' + outBuffer[i].toString(16));
		}
	}

	document.getElementById('go').addEventListener('click', function() {
		main();
	});

</script>
</html>
